= Introduction =

The dispatcher is the core of the framework.

The dispatcher is mainly responsible to
  * read and parse the request 
  * serve the response to the client 
  * delegate anything in between

Our framework class naming convention is following the [http://www.php-fig.org/ PHP Framework Interoperability Group] Standard: *PSR-0 Autoloading Standard*

{{{
nulltype import(string name) throws ClassNotFoundException
}}}

Imports a given class using its fully qualified name (but using dot syntax instead of backslash). This mechanism is emulating namespaces on PHP < 5.3.0 - because namespace feature was not provided by the language prior to PHP 5.3.0. In newer version of PHP it is still recommended to use this in order to keep your code  portable.

It has been introduced, to improve bytecode cache performances, as a replacement of the initial Barebone MVC class autoloader. 

*Rasmus Lerdorf*: 
  To clarify, of course conditionally included files get compiled and   cached. The issue is not the included files but the resulting conditionally defined classes and functions needing to be redefined on every request. Whether that is significant or not comes down to the specifics of the situation, but there is no doubt that it is slower. It comes down to a NOP vs. a FETCH_CLASS, for example and the NOP is obviously way faster.

{{{
object construct(string name[, false]) throws ClassNotFoundException
}}}

Creates a new instance of the given class using its fully qualified name (but using dot syntax instead of backslash). Note that you have to import the class using *import()* before calling *construct()*. 

{{{
// For example instead of the following statement
// as you would use it for PHP >= 5.3.0
$obj = new \foo\bar\ClassName();

// or prior to PHP 5.3.0
$obj = new foo_bar_ClassName();

// you would normally have the following:
$obj = construct('foo.bar.ClassName');
}}}

{{{
object construct(string name, true) throws ClassNotFoundException, InstantiationException
}}}

To use a _single instance of the type_ you have to pass *true* as second argument to the function. 

The _name_ must be a fully qualified class name (but using dot syntax instead of backslash)

Given type is required to implement a mechanism to create and return the instance, either:
  # implement _a function with the same name as the class_
  # implement *Singleton::instance()* or *ISingleton::getInstance()* and _define a private constructor_

*Not implemented yet:* If you request a singleton for a type whose constructor is not private and a function with the same name as the class is not defined then an *InstantiationException* shall be thrown.

    ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException, NoSuchMethodException

{{{
object singleton(string name, ...)
}}}

It is the singleton formal factory method provided by the framework.

This is especially useful to create singletons of classes provided by third party libraries.

Use this function when you want to ensure usage of a single instance but don't want to create a function for each type, add a *getInstance()* method to each class or refactor libraries to change constructors access level.


{{{
object require_object(string name[, callable callback])
}}}

Creates the required object after it automatically loads the class. 

If a callback is provided, then the object is passed to the callback and the return value the callback is fetched back.

The main diference between require_object() and {import(), construct()} is that require_object() is used for lazy loading of the class.

{{{
object require_class(string name[, callable callback])
}}}