= The `Config` Class =

The `Config` class is a *Key-Value-Type store*.

That is a key-value store, but inside each value caries its own associated type.

Without using this feature, each time you request a field value from a database you will get a string - and you have to manually convert the value to the assumed type. _Maybe the assumed type it is the correct one, but you could also be wrong_.

== Basic Feature ==

In order to *avoid assuming the correct type*, this function converts the stored string value to the suitable type for the variable - that type is stored internally in the database.

== Extended Feature ==

Another important feature is that object data is automatically serialized into a specific form in the database, and they are automatically unserialized when you are accessing the key.

=== Reading Values ===

{{{
public variant Config::get(string name) [static]

public variant Config::get(string name, variant defaultValue) [static]
}}}

|| *name* || the name of the key you need to read ||
|| *defaultValue* || ... ||
|| *returns* || <div>the value of the key</div> <div> a `variant` that can have one of the following supported types:  `boolean`, `float`, `integer`, `string`, `object`, `array` (for both `list` and `dictionary`).</div> ||

=== Writing Values / Creating New Keys ===

New keys are automatically created when you are trying to set the value for a key that doesn't exists already. You don't have to worry about this issue. No existence check or create calls are necessary.

[http://ro1.php.net/manual/en/class.serializable.php Serializable interface]

{{{
public nulltype Config::set(string name, variant value, string type) [static]

public nulltype Config::set(string name, variant value) [static]
}}}

Converts the _value_ to the specified _type_ and stores it into the database (using the representation format specified by _type_).

|| *name* || the name of the key you want to write (or create) ||
|| *value* || value to be stored into the database ||
|| *type* || <div>in case that _value_ has primitive types: a long standard type name</div><ul><li>`'boolean'`</li><li> `'float'`</li><li>`'integer'`</li><li>`'string'`</li></ul><div> in case that _value_ is an objects an array: the serialization method must be specified</div><div><ul><li>`'json'`</li><li>`'base64'`</li><li>`'hexdump'` (not implemented)</li><li>`'serialize'` (not recommended, use `'json'` instead)</li><li>`'yaml'` (proposal)</li><li> `'xml'` (proposal)</li></ul></div><div> `[default]` If `type` is omitted, the current variable type is used for primitive types - requested with `gettype()` </div><div>For objects, the `json` serialization method is the default. </div> ||
|| *returns* || `null` - Nothing to return. If something is wrong and exception is thrown. ||

Set mupliple keys at once ... TODO: single insert.

{{{
public nulltype Config::set(array values, string type) [static]
}}}

== Caching ==

The `Config::get()` method result is cached internally.