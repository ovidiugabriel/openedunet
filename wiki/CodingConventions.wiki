<wiki:toc />

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

== Editor Settings ==

=== Sublime Settings ===

Preferences > Settings-User ... 
Packages\User\Preferences.sublime-settings

*Sublime settings are highlighted between { and }*

{{{
{
    // Encoding used when saving new files, and files opened with an undefined
    // encoding (e.g., plain ascii files). If a file is opened with a specific
    // encoding (either detected or given explicitly), this setting will be
    // ignored, and the file will be saved with the encoding it was opened
    // with.
    "default_encoding": "UTF-8",

    // The number of spaces a tab is considered equal to
    "tab_size": 4, 

    // Set to true to insert spaces when tab is pressed
    "translate_tabs_to_spaces": true,

    // Columns in which to display vertical rulers
    "rulers": [80, 120],

    // Determines what character(s) are used to terminate each line in new files.
    // Valid values are 'system' (whatever the OS uses), 'windows' (CRLF) and
    // 'unix' (LF only).
    "default_line_ending": "unix",

    // Set to true to ensure the last line of the file ends in a newline
    // character when saving
    "ensure_newline_at_eof_on_save": true
}
}}}

== PSR Standards ==

==== PSR-0 Autoloading ====

==== PSR-1 Basic Coding ====

  # PHP code MUST use the long `<?php ?>` tags; it MUST NOT use the other tag variations.
  # Code files MUST use only UTF-8 {`"default_encoding": "UTF-8"`}
  # Files SHOULD either declare symbols (classes, functions, constants, etc.) or cause side-effects (e.g. generate output, change .ini settings,explicit use of require or include, connecting to external services, emitting errors or exceptions, modifying global or static variables, reading from or writing to a file, etc.) but SHOULD NOT do both.
  # Namespaces and classes MUST follow PSR-0.
  # Class names MUST be declared in `StudlyCaps`

==== PSR-2 Coding Style ====

  # Code MUST use 4 spaces for indenting, not tabs. {`"tab_size": 4, "translate_tabs_to_spaces": true`}
  # There MUST NOT be a hard limit on line length; the soft limit MUST be 120 characters; {` "rulers": [80, 120]`}
  # Visibility MUST be declared on all properties and methods; 
  # `abstract` and `final` MUST be declared before the visibility; 
  # The `var` keyword MUST NOT be used to declare a property. 
  # Property names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility
  # Opening braces for control structures MUST go on the same line, and closing braces MUST go on the next line after the body.
  # All code files MUST use the Unix LF (linefeed) line ending. {`"default_line_ending": "unix"`}
  # All code files MUST end with a single blank line. {`"ensure_newline_at_eof_on_save": true`}
  # The closing `?>` tag MUST be omitted from files containing only PHP.
  # PHP keywords MUST be in lower case. The PHP constants `true`, `false`, and `null` MUST be in lower case.
  # The `extends` and `implements` keywords MUST be declared on the same line as the class name.
  # Lists of implements MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line.
  # In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.
  # Method arguments with default values MUST go at the end of the argument list.
  # Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line.
  # The keyword `elseif` SHOULD be used instead of else if so that all control keywords look like single words.

==== PSR-4 Improved Autoloading ====

== Aditional specific conventions ==

  # Usage of `static` methods and `static` local variables is discouraged. Make sure you have an object oriented or a functional design before using `static`. And make sure you are not forcing procedural style over classes by using `static` in excess. If you still need to use `static` methods make sure that `static` keyword is written on the line above the method signature.

{{{
    /** 
     *
     */
    static
    public function FunctionName($value='')
    {
        # code...
    }
}}}

== Naming Conventions ==

*What about letter cases and underscores?*

We have a very _liberal approach_ in this area. 

As _Linus Torvalds_ said: _"Coding style is very personal, and I won't force my views on anybody, but this is what goes for anything that I have to be able to maintain"_.

Maybe it is confusing,
but it is important to keep in mind only one rule: *don't put everything in the same basket*.

  # Constants are always `SCREAMING_CAPS`;
  # Local variables, object properties and function parameters are `snake_case`;
  # Functions and methods are generally `camelCase`;

Usually I stick to the same convetions as [http://blog.lmorchard.com/2013/01/23/naming-conventions Les Orchard].

These rules are not mandatory, they are just advisory and won't be enforced on contributors.

After all, computer programming is about data structures, algorithms, architectures and interfaces and not so much about text formatting and typography.

*What about hungarian notation?*

Hungarian notation is a naming anti-pattern in modern day programming environments and form of Tautology. It violates the DRY principle.

It is generally a sign of breaking encapsulation, it obfuscates identifiers and makes code prone to confusion due to accidental erroneous use. In other words it makes wrong code impossible to read - what I can't read with loud voice I cannot debug.

*Prefixing that way is not needed really, and it is not allowed in this project, except rare situations.*

Here it is _Linus Torvalds_ (the father of Linux) opinion on this: _"Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged -- the compiler knows the types anyway and can check those, and it only confuses the programmer. No wonder Micro $$oft makes buggy programs"_

This technique was important in BCPL programming language because BCPL has no data types other than the machine word. Or it can be useful for assembly language.

Here it is _Bjarne Stroustrup_ (the father of C++) opinion on this issue:
_"This technique that can be useful in untyped languages, but is completely unsuitable for a language that supports generic programming and object-oriented programming—both of which emphasize selection of operations based on the type an arguments. In this case, 'building the type of an object into names' simply complicates and minimizes abstraction."_

Don't try to be smarter than _Bjarne Stroustrup_ and _Linus Torvalds_.

Hungarian notation doesn't help even for scripting languages. - For modern reflective scripting languages the object type is a property of the object not a part of the name. 

Don't be fooled  by the fact that type declaration is not mandatory. That doesn't mean that variables do not have a type - it is just encapsulated by its internal variant. This is *a feature of object orientation*.

{{{
$X = "0"; // here X is a string
$Y = 0;   // here Y is an integer
$Z = 0.0; // here Z is a float

$A = [1, 2, 3, 4]; // here A is an array
}}}

However if the type is judged as interface we have subtyping polymorphism.

It has been proved that hungarian notation can only lead to confusion because unique tags must be defined for type definitions and instance variables; but this must be done for each project, module, company, team etc. Better you use that time to learn practical stuff like multiple programming languages, paradigms, algorithms and software architecture than wasting time to train you on some arbitrary fantasies.

  # *b* prefix can stand for both `boolean` and `byte`
  # *s* prefix can stands for both `string` and `struct`
  # *f* prefix can stands for both `boolean` and `float`

Simonyi Károly mistakenly used the word `type` in his paper, and generations of programmers misunderstood what he meant. Maybe he was talking about _kind_ and _purpose_.

Usually I remember only the first letters of a variable name, so it is  better use a suffix than a prefix.

|| *Suffix* || *Variable type* ||
|| `_String` || For all string types: `char[]`, `std::string`, `QString`, etc ||
|| `_Integer` || all types of `integer` ||
|| `_Rational` || all types of `float` ||
|| `_Complex` || `complex` ||
|| `_Number` || all types of `integer` and `float` ||
|| `_List` || ... ||
|| `_Vector` || ... ||
|| `_Matrix` || ... ||
|| `_Array` || ... ||
|| `_Polynomial` || ... ||
|| `_typename` ||  for all `enum typename`, `struct typename`, `class typename`, `union typename` never use `_enum`, `_struct`, `_class` or `_union` as suffixes ||

== Design Principles ==

Forget about CodingConventions. We are more concerned with:
  * [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself DRY Principle]
  * [http://en.wikipedia.org/wiki/Separation_of_concerns Separation of concerns]
  * [http://en.wikipedia.org/wiki/Code_reuse Code reuse]
  * [http://en.wikipedia.org/wiki/Abstraction_principle_%28programming%29 Abstraction principles]

And speaking about DRY Principle: *Avoid [http://en.wikipedia.org/wiki/Copy_and_paste_programming Copy and paste programming] and [http://en.wikipedia.org/wiki/Cargo_cult_programming Cargo cult programming] at any price, dead or alive, no matter what.*

[http://ilpverymuch.wordpress.com/2014/06/23/10-steps-to-becoming-a-better-programmer/ 10 steps to becoming a better programmer]

*Other anti-patterns to avoid:*
  
  * [http://en.wikipedia.org/wiki/Copy_and_paste_programming Copy and paste programming]
  * [http://en.wikipedia.org/wiki/Duplicate_code Duplicated code]: identical or very similar code exists in more than one location.
  * [http://en.wikipedia.org/wiki/Cargo_cult_programming Cargo cult programming]
  * *Code Distrust*: checking to see if a `boolean`-typed variable is something other than `true` or `false`; Using `if (true == (true == x))` instead of `if (x)` when `x` is a boolean variable, etc.
  * *Smart UI Anti-Pattern* (See: [http://geekswithblogs.net/gregorymalcolm/archive/2009/07/14/user-interface-patterns.aspx Using Interface Patterns] - includes details on MVC and so on)
  * [http://c2.com/cgi/wiki?ArrowAntiPattern Arrow Anti-Pattern]: It often develops when a programmer applies the 'One Return Per Function rule' blindly and in poor taste
  * [http://www.leepoint.net/JavaBasics/methods/method-commentary/methcom-30-multiple-return.html One Return Per Function ]: simple readable code in more important than following any arbitrary rule.
  * *Loop-switch sequence*: Encoding a set of sequential steps using a switch within a loop statement
  * [http://en.wikipedia.org/wiki/Error_hiding Error hiding]: Catching an error message before it can be shown to the user and either showing nothing or showing a meaningless message. Checking results without throwing exceptions or forwarding error codes and messages to both caller and logging system.
  * *Pinball Programming*: Using code that doesn't throw exceptions, and not checking the output result. Blindly using running over errors with faith that everything is fine since the system has `display_errors` muted.
  * *Hard code*: Embedding assumptions about the environment of a system in its implementation
  * *Inappropriate intimacy*: a class that has dependencies on implementation details of another class.
  * *Fat Controller Anti-Pattern*
  * [http://en.wikipedia.org/wiki/God_object God Object]: Concentrating too many functions in a single part of the design (class)
  * [http://en.wikipedia.org/wiki/Object_orgy Object Orgy]:  Failing to properly encapsulate objects permitting unrestricted access to their internals
  * *Premature optimization*: Coding early-on for perceived efficiency, sacrificing good design, maintainability, and sometimes even real-world efficiency - D. Knuth: "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil."

Over engineering? Redundant stuff?

Let's have an example: 
{{{
if (numMines > 0)
{
   enabled=true;
}
else
{
   enabled=false;
}
}}}

Why would you do that when you could just use:
{{{
enabled = (numMines > 0);
}}}

== PHP specific standards ==

  # Access type `abstract` for interface methods must be omitted.