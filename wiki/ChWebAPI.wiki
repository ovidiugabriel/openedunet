Ch is a C/C++ dialect. It is an interpretive implementation of C with salient features from C++, other languages and software packages for scripting, rapid application development, deployment, and integration with legacy systems. 


= Types =

== `FP` ==

{{{
typedef void* (*FP) (...);
}}}

= Macros =

== `FP_CALLBACK()` ==

{{{
#define FP_CALLBACK(p)  ((FP) (p))
}}}

== `COUNT()` ==

{{{
#define COUNT(x)        (sizeof(x)/sizeof((x)[0]))
}}}

== Deferred-Shape array ==

{{{
/**
 * A deferred-shape array is an array pointer or an allocatable array. 
 */
#if defined(_CH_)
    /* Deferred-shape array is created with the syntax of the language */
    #define CREATE_DEFERRED_SHAPE_ARRAY(type, name, num)    type name[0:(num)-1]
 
#elif !defined(_SCH_)
    /* 
     * Deferred-shape array is created with dynamic allocation of the operating system.
     * When using this, always use RAII pattern. 
     * (http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)
     */
    #define CREATE_DEFERRED_SHAPE_ARRAY(type, name, num)    type* name = (type*) malloc((num) * sizeof(type))
#endif
}}}

= Functions =

=== `request_scalar()` ===

{{{
string_t request_scalar(string_t name)
}}}

|| *`name`* || ... ||
|| *returns* || ... ||

This does the same as calling `Request.getForm(name)`.
And it is the same as `$_REQUEST[name]` in PHP.

=== `request_array()` ===

{{{
gint request_array(string_t key, gchar**& vals)
}}}

|| *`key`* || ... ||
|| *returns* || ... ||

This is the same as calling `Request.getForms(strcat(key, "[]"), vals)`.

And it is also the same as `$_REQUEST[name]` in PHP - but where it is automatically detected that `$_REQUEST[name]` is an array while in Ch CGI you have to assume (although you would say it is written it is part of an interface contract) that `name` is an array to decide to use `request_array()`.

=== `doubleval()` ===

{{{
gdouble doubleval(string_t str)
}}}

|| *`str`* || ... ||
|| *returns* || ... ||

It is the same as `doubleval()` or `floatval()` in PHP - where both `float` and `double` are on 64-bits. Here in Ch, like in C/C++, only `double` is on 64-bits.

=== `get_double_values()` ===

{{{
void get_double_values(gdouble* result, string_t* values, gint num)
}}}

|| *`result`* || ... ||
|| *`values`* || ... ||
|| *`num`* || ... ||
|| *returns* || ... ||

Of course this is the same as running `doubleval()` on `values` with `array_map()` and storing the output in `result`.

=== `array_map()` ===

{{{
void array_map(void* result, FP callback, void* values, int count)
}}}

=== `double_value_array()` ===

{{{
void double_value_array(gdouble* result, string_t* values, gint index)
}}}

== Strings ==

Types `char` and `wchar_t` are used to define variables of characters and wide characters in Ch.

The value of a variable of type `char` is a single character or escape sequence which is enclosed in singlequotes,
as in `'x'`. A character constant has type `int` in C. Like C++, a character constant has type `char` in
Ch.

For string functions *`strcpy()`*, *`strncpy()`*, *`strcat()`*, and *`strncat()`*, the memory will be automatically handled
if the first argument is of the type *`string t`*.

{{{
int strcasecmp(char *s1, char *s2);
}}}

{{{
char* strconcat (const char *string1, ...);
}}}


{{{
char* strjoin(const char *separator, ...);
}}}

{{{
int strncasecmp(char *s1, char *s2, int n);
}}}

{{{
unsigned int str2ascii(char *s);
}}}

{{{
int str2mat(char mat[:][:], string_t s1, ...);
}}}

{{{
char strgetc(string_t &s, int i);
}}}

{{{
int strputc(string_t &s, int i, char c);
}}}

{{{
string_t strrep(string_t s1, string_t s2, string_t s3);
}}}